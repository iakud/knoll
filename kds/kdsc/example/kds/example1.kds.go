// Code generated by kds. DO NOT EDIT.
// source: example1.kds

package kds;

import (
	"iter"
	"maps"
	"time"

	"github.com/iakud/krocher/kds/kdsc/example/kdspb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type syncablePlayer struct {
	Info *PlayerBasicInfo
	Hero *PlayerHero
	Bag *PlayerBag
}

type Player struct {
	id int64
	syncable syncablePlayer

	dirty uint64
}

func NewPlayer() *Player {
	x := new(Player)
	x.dirty = 1
	x.id = 0 // FIXME: gen nextId()
	x.setInfo(NewPlayerBasicInfo())
	x.setHero(NewPlayerHero())
	x.setBag(NewPlayerBag())
	return x
}

func (x *Player) Id() int64 {
	return x.id
}

func (x *Player) GetInfo() *PlayerBasicInfo {
	return x.syncable.Info
}

func (x *Player) setInfo(v *PlayerBasicInfo) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable.Info {
		return
	}
	if x.syncable.Info != nil {
		x.syncable.Info.dirtyParent = nil
	}
	x.syncable.Info = v
	v.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
	x.markDirty(uint64(0x01) << 1)
	if v != nil {
		v.markDirty(uint64(0x01))
	}
}

func (x *Player) GetHero() *PlayerHero {
	return x.syncable.Hero
}

func (x *Player) setHero(v *PlayerHero) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable.Hero {
		return
	}
	if x.syncable.Hero != nil {
		x.syncable.Hero.dirtyParent = nil
	}
	x.syncable.Hero = v
	v.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 2)
	}
	x.markDirty(uint64(0x01) << 2)
	if v != nil {
		v.markDirty(uint64(0x01))
	}
}

func (x *Player) GetBag() *PlayerBag {
	return x.syncable.Bag
}

func (x *Player) setBag(v *PlayerBag) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable.Bag {
		return
	}
	if x.syncable.Bag != nil {
		x.syncable.Bag.dirtyParent = nil
	}
	x.syncable.Bag = v
	v.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 3)
	}
	x.markDirty(uint64(0x01) << 3)
	if v != nil {
		v.markDirty(uint64(0x01))
	}
}

func (x *Player) DumpChange() *kdspb.Player {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.Player)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Info = x.syncable.Info.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.Hero = x.syncable.Hero.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.Bag = x.syncable.Bag.DumpChange()
	}
	return m
}

func (x *Player) DumpFull() *kdspb.Player {
	m := new(kdspb.Player)
	m.Info = x.syncable.Info.DumpFull()
	m.Hero = x.syncable.Hero.DumpFull()
	m.Bag = x.syncable.Bag.DumpFull()
	return m
}

func (x *Player) markAll() {
	x.dirty = uint64(0x01)
}

func (x *Player) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
}

func (x *Player) clearAll() {
	x.syncable.Info.clearDirty()
	x.syncable.Hero.clearDirty()
	x.syncable.Bag.clearDirty()
	x.dirty = 0
}

func (x *Player) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	if x.dirty & uint64(0x01) << 1 != 0 {
		x.syncable.Info.clearDirty()
	}
	if x.dirty & uint64(0x01) << 2 != 0 {
		x.syncable.Hero.clearDirty()
	}
	if x.dirty & uint64(0x01) << 3 != 0 {
		x.syncable.Bag.clearDirty()
	}
	x.dirty = 0
}

func (x *Player) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncablePlayerBasicInfo struct {
	Name string
	IsNew bool
	CreateTime time.Time
}

type dirtyParentFunc_PlayerBasicInfo func()

func (f dirtyParentFunc_PlayerBasicInfo) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBasicInfo struct {
	syncable syncablePlayerBasicInfo

	dirty uint64
	dirtyParent dirtyParentFunc_PlayerBasicInfo
}

func NewPlayerBasicInfo() *PlayerBasicInfo {
	x := new(PlayerBasicInfo)
	x.dirty = 1
	return x
}

func (x *PlayerBasicInfo) GetName() string {
	return x.syncable.Name
}

func (x *PlayerBasicInfo) SetName(v string) {
	if v == x.syncable.Name {
		return
	}
	x.syncable.Name = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *PlayerBasicInfo) GetIsNew() bool {
	return x.syncable.IsNew
}

func (x *PlayerBasicInfo) SetIsNew(v bool) {
	if v == x.syncable.IsNew {
		return
	}
	x.syncable.IsNew = v
	x.markDirty(uint64(0x01) << 3)
}

func (x *PlayerBasicInfo) GetCreateTime() time.Time {
	return x.syncable.CreateTime
}

func (x *PlayerBasicInfo) SetCreateTime(v time.Time) {
	if v == x.syncable.CreateTime {
		return
	}
	x.syncable.CreateTime = v
	x.markDirty(uint64(0x01) << 5)
}

func (x *PlayerBasicInfo) DumpChange() *kdspb.PlayerBasicInfo {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerBasicInfo)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Name = x.syncable.Name
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.IsNew = x.syncable.IsNew
	}
	if x.checkDirty(uint64(0x01) << 5) {
		m.CreateTime = timestamppb.New(x.syncable.CreateTime)
	}
	return m
}

func (x *PlayerBasicInfo) DumpFull() *kdspb.PlayerBasicInfo {
	m := new(kdspb.PlayerBasicInfo)
	m.Name = x.syncable.Name
	m.IsNew = x.syncable.IsNew
	m.CreateTime = timestamppb.New(x.syncable.CreateTime)
	return m
}

func (x *PlayerBasicInfo) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerBasicInfo) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerBasicInfo) clearAll() {
	x.dirty = 0
}

func (x *PlayerBasicInfo) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	x.dirty = 0
}

func (x *PlayerBasicInfo) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncablePlayerHero struct {
	Heroes Int64_Hero_Map
}

type dirtyParentFunc_PlayerHero func()

func (f dirtyParentFunc_PlayerHero) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerHero struct {
	syncable syncablePlayerHero

	dirty uint64
	dirtyParent dirtyParentFunc_PlayerHero
}

func NewPlayerHero() *PlayerHero {
	x := new(PlayerHero)
	x.dirty = 1
	x.initHeroes()
	return x
}

func (x *PlayerHero) GetHeroes() *Int64_Hero_Map {
	return &x.syncable.Heroes
}

func (x *PlayerHero) initHeroes() {
	x.syncable.Heroes.syncable = make(map[int64]*Hero)
	x.syncable.Heroes.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *PlayerHero) DumpChange() *kdspb.PlayerHero {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerHero)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Heroes = x.syncable.Heroes.DumpChange()
	}
	return m
}

func (x *PlayerHero) DumpFull() *kdspb.PlayerHero {
	m := new(kdspb.PlayerHero)
	m.Heroes = x.syncable.Heroes.DumpFull()
	return m
}

func (x *PlayerHero) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerHero) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerHero) clearAll() {
	x.syncable.Heroes.clearDirty()
	x.dirty = 0
}

func (x *PlayerHero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	if x.dirty & uint64(0x01) << 1 != 0 {
		x.syncable.Heroes.clearDirty()
	}
	x.dirty = 0
}

func (x *PlayerHero) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncablePlayerBag struct {
	Resources Int32_Int32_Map
}

type dirtyParentFunc_PlayerBag func()

func (f dirtyParentFunc_PlayerBag) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBag struct {
	syncable syncablePlayerBag

	dirty uint64
	dirtyParent dirtyParentFunc_PlayerBag
}

func NewPlayerBag() *PlayerBag {
	x := new(PlayerBag)
	x.dirty = 1
	x.initResources()
	return x
}

func (x *PlayerBag) GetResources() *Int32_Int32_Map {
	return &x.syncable.Resources
}

func (x *PlayerBag) initResources() {
	x.syncable.Resources.syncable = make(map[int32]int32)
	x.syncable.Resources.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *PlayerBag) DumpChange() *kdspb.PlayerBag {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerBag)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Resources = x.syncable.Resources.DumpChange()
	}
	return m
}

func (x *PlayerBag) DumpFull() *kdspb.PlayerBag {
	m := new(kdspb.PlayerBag)
	m.Resources = x.syncable.Resources.DumpFull()
	return m
}

func (x *PlayerBag) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerBag) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerBag) clearAll() {
	x.syncable.Resources.clearDirty()
	x.dirty = 0
}

func (x *PlayerBag) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	if x.dirty & uint64(0x01) << 1 != 0 {
		x.syncable.Resources.clearDirty()
	}
	x.dirty = 0
}

func (x *PlayerBag) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncableHero struct {
	HeroId int32
	HeroLevel int32
	Type HeroType
	NeedTime time.Duration
}

type dirtyParentFunc_Hero func()

func (f dirtyParentFunc_Hero) invoke() {
	if f == nil {
		return
	}
	f()
}

type Hero struct {
	syncable syncableHero

	dirty uint64
	dirtyParent dirtyParentFunc_Hero
}

func NewHero() *Hero {
	x := new(Hero)
	x.dirty = 1
	return x
}

func (x *Hero) GetHeroId() int32 {
	return x.syncable.HeroId
}

func (x *Hero) SetHeroId(v int32) {
	if v == x.syncable.HeroId {
		return
	}
	x.syncable.HeroId = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *Hero) GetHeroLevel() int32 {
	return x.syncable.HeroLevel
}

func (x *Hero) SetHeroLevel(v int32) {
	if v == x.syncable.HeroLevel {
		return
	}
	x.syncable.HeroLevel = v
	x.markDirty(uint64(0x01) << 2)
}

func (x *Hero) GetType() HeroType {
	return x.syncable.Type
}

func (x *Hero) SetType(v HeroType) {
	if v == x.syncable.Type {
		return
	}
	x.syncable.Type = v
	x.markDirty(uint64(0x01) << 3)
}

func (x *Hero) GetNeedTime() time.Duration {
	return x.syncable.NeedTime
}

func (x *Hero) SetNeedTime(v time.Duration) {
	if v == x.syncable.NeedTime {
		return
	}
	x.syncable.NeedTime = v
	x.markDirty(uint64(0x01) << 4)
}

func (x *Hero) DumpChange() *kdspb.Hero {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.Hero)
	if x.checkDirty(uint64(0x01) << 1) {
		m.HeroId = x.syncable.HeroId
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.HeroLevel = x.syncable.HeroLevel
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.Type = x.syncable.Type
	}
	if x.checkDirty(uint64(0x01) << 4) {
		m.NeedTime = durationpb.New(x.syncable.NeedTime)
	}
	return m
}

func (x *Hero) DumpFull() *kdspb.Hero {
	m := new(kdspb.Hero)
	m.HeroId = x.syncable.HeroId
	m.HeroLevel = x.syncable.HeroLevel
	m.Type = x.syncable.Type
	m.NeedTime = durationpb.New(x.syncable.NeedTime)
	return m
}

func (x *Hero) markAll() {
	x.dirty = uint64(0x01)
}

func (x *Hero) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *Hero) clearAll() {
	x.dirty = 0
}

func (x *Hero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	x.dirty = 0
}

func (x *Hero) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_Int64_Hero_Map func()

func (f dirtyParentFunc_Int64_Hero_Map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int64_Hero_Map struct {
	syncable map[int64]*Hero

	new map[int64]*Hero
	deleteKey map[int64]struct{}
	clear bool
	dirty bool
	dirtyParent dirtyParentFunc_Int64_Hero_Map
}

func (x *Int64_Hero_Map) Len() int {
	return len(x.syncable)
}

func (x *Int64_Hero_Map) Clear() {
	if len(x.syncable) == 0 && len(x.deleteKey) == 0 {
		return
	}
	for _, v := range x.syncable {
		if v != nil {
			v.dirtyParent = nil
		}
	}
	clear(x.syncable)
	clear(x.new)
	clear(x.deleteKey)
	x.clear = true
	x.markDirty()
}

func (x *Int64_Hero_Map) Get(k int64) (*Hero, bool) {
	v, ok := x.syncable[k]
	return v, ok
}

func (x *Int64_Hero_Map) Set(k int64, v *Hero) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if e, ok := x.syncable[k]; ok {
		if e == v {
			return
		}
		if e != nil {
			e.dirtyParent = nil
		}
	}
	x.syncable[k] = v
	if v != nil {
		v.dirtyParent = func() {
			if _, ok := x.new[k]; ok {
				return
			}
			x.new[k] = v
			x.markDirty()
		}
		v.dirty |= uint64(0x01)
	}
	x.new[k] = v
	delete(x.deleteKey, k)
	x.markDirty()
}

func (x *Int64_Hero_Map) Delete(k int64) {
	if v, ok := x.syncable[k]; ok && v != nil {
		v.dirtyParent = nil
	}
	delete(x.syncable, k)
	x.deleteKey[k] = struct{}{}
	delete(x.new, k)
	x.markDirty()
}

func (x *Int64_Hero_Map) All() iter.Seq2[int64, *Hero] {
	return maps.All(x.syncable)
}

func (x *Int64_Hero_Map) Keys() iter.Seq[int64] {
	return maps.Keys(x.syncable)
}

func (x *Int64_Hero_Map) Values() iter.Seq[*Hero] {
	return maps.Values(x.syncable)
}

func (x *Int64_Hero_Map) DumpChange() map[int64]*kdspb.Hero {
	m := make(map[int64]*kdspb.Hero)
	for k, v := range x.syncable {
		m[k] = v.DumpFull()
	}
	return m
}

func (x *Int64_Hero_Map) DumpFull() map[int64]*kdspb.Hero {
	m := make(map[int64]*kdspb.Hero)
	for k, v := range x.syncable {
		m[k] = v.DumpFull()
	}
	return m
}

func (x *Int64_Hero_Map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int64_Hero_Map) clearDirty() {
	for _, v := range x.new {
		if v != nil {
			v.clearDirty()
		}
	}
	clear(x.new)
	clear(x.deleteKey)
	x.clear = false
	x.dirty = false
}

type HeroType = kdspb.HeroType

const (
	HeroType_HeroType1 HeroType = 0
	HeroType_HeroType2 HeroType = 2
	HeroType_HeroType3 HeroType = -5
)