// Code generated by kds. DO NOT EDIT.
// source: example\example1.kds

package kds

import (
	"iter"
	"maps"
	"time"

	"github.com/iakud/knoll/kds/kdsc/example/kdspb"
	"github.com/iakud/knoll/kds/wire"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type Player struct {
	id int64
	xxx_hidden_Info *PlayerBasicInfo
	xxx_hidden_Hero *PlayerHero
	xxx_hidden_Bag *PlayerBag

	dirty uint64
}

func NewPlayer(id int64) *Player {
	x := new(Player)
	x.id = id
	x.setInfo(NewPlayerBasicInfo())
	x.setHero(NewPlayerHero())
	x.setBag(NewPlayerBag())
	x.dirty = 1
	return x
}

func (x *Player) Id() int64 {
	return x.id
}

func (x *Player) GetInfo() *PlayerBasicInfo {
	return x.xxx_hidden_Info
}

func (x *Player) setInfo(v *PlayerBasicInfo) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed from its original place first")
	}
	if v == x.xxx_hidden_Info {
		return
	}
	if x.xxx_hidden_Info != nil {
		x.xxx_hidden_Info.dirtyParent = nil
	}
	x.xxx_hidden_Info = v
	if v != nil {
		v.dirtyParent = func() {
			x.markDirty(uint64(0x01) << 1)
		}
		v.dirty |= uint64(0x01)
	}
	x.markDirty(uint64(0x01) << 1)
}

func (x *Player) GetHero() *PlayerHero {
	return x.xxx_hidden_Hero
}

func (x *Player) setHero(v *PlayerHero) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed from its original place first")
	}
	if v == x.xxx_hidden_Hero {
		return
	}
	if x.xxx_hidden_Hero != nil {
		x.xxx_hidden_Hero.dirtyParent = nil
	}
	x.xxx_hidden_Hero = v
	if v != nil {
		v.dirtyParent = func() {
			x.markDirty(uint64(0x01) << 2)
		}
		v.dirty |= uint64(0x01)
	}
	x.markDirty(uint64(0x01) << 2)
}

func (x *Player) GetBag() *PlayerBag {
	return x.xxx_hidden_Bag
}

func (x *Player) setBag(v *PlayerBag) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed from its original place first")
	}
	if v == x.xxx_hidden_Bag {
		return
	}
	if x.xxx_hidden_Bag != nil {
		x.xxx_hidden_Bag.dirtyParent = nil
	}
	x.xxx_hidden_Bag = v
	if v != nil {
		v.dirtyParent = func() {
			x.markDirty(uint64(0x01) << 3)
		}
		v.dirty |= uint64(0x01)
	}
	x.markDirty(uint64(0x01) << 3)
}

func (x *Player) DumpChange() *kdspb.Player {
	if x.dirty&uint64(0x01) != 0 {
		return x.DumpFull()
	}
	m := new(kdspb.Player)
	if x.dirty&(uint64(0x01)<<1) != 0 {
		m.SetInfo(x.xxx_hidden_Info.DumpChange())
	}
	if x.dirty&(uint64(0x01)<<2) != 0 {
		m.SetHero(x.xxx_hidden_Hero.DumpChange())
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		m.SetBag(x.xxx_hidden_Bag.DumpChange())
	}
	return m
}

func (x *Player) DumpFull() *kdspb.Player {
	m := new(kdspb.Player)
	m.SetInfo(x.xxx_hidden_Info.DumpFull())
	m.SetHero(x.xxx_hidden_Hero.DumpFull())
	m.SetBag(x.xxx_hidden_Bag.DumpFull())
	return m
}

func (x *Player) Load(m *kdspb.Player) {
	x.xxx_hidden_Info.Load(m.GetInfo())
	x.xxx_hidden_Hero.Load(m.GetHero())
	x.xxx_hidden_Bag.Load(m.GetBag())
}

func (x *Player) Marshal(b []byte) ([]byte, error) {
	var err error
	if b, err = wire.MarshalMessage(b, 1, x.xxx_hidden_Info); err != nil {
		return b, err
	}
	if b, err = wire.MarshalMessage(b, 2, x.xxx_hidden_Hero); err != nil {
		return b, err
	}
	if b, err = wire.MarshalMessage(b, 3, x.xxx_hidden_Bag); err != nil {
		return b, err
	}
	return b, err
}

func (x *Player) MarshalDirty(b []byte) ([]byte, error) {
	if x.dirty&uint64(0x01) != 0 {
		return x.Marshal(b)
	}
	var err error
	if x.dirty&(uint64(0x01)<<1) != 0 {
		if b, err = wire.MarshalMessageDirty(b, 1, x.xxx_hidden_Info); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<2) != 0 {
		if b, err = wire.MarshalMessageDirty(b, 2, x.xxx_hidden_Hero); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		if b, err = wire.MarshalMessageDirty(b, 3, x.xxx_hidden_Bag); err != nil {
			return b, err
		}
	}
	return b, err
}

func (x *Player) Unmarshal(b []byte) error {
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case 1:
			valLen, err = wire.UnmarshalMessage(b[tagLen:], wtyp, x.xxx_hidden_Info)
		case 2:
			valLen, err = wire.UnmarshalMessage(b[tagLen:], wtyp, x.xxx_hidden_Hero)
		case 3:
			valLen, err = wire.UnmarshalMessage(b[tagLen:], wtyp, x.xxx_hidden_Bag)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	return nil
}

func (x *Player) markAll() {
	x.dirty = uint64(0x01)
}

func (x *Player) markDirty(n uint64) {
	if x.dirty&n == n {
		return
	}
	x.dirty |= n
}

func (x *Player) checkDirty(n uint64) bool {
	return x.dirty&n != 0
}

func (x *Player) CheckDirty() bool {
	return x.dirty != 0
}

func (x *Player) ClearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty&uint64(0x01) != 0 || x.dirty&(uint64(0x01)<<1) != 0 {
		x.xxx_hidden_Info.clearDirty()
	}
	if x.dirty&uint64(0x01) != 0 || x.dirty&(uint64(0x01)<<2) != 0 {
		x.xxx_hidden_Hero.clearDirty()
	}
	if x.dirty&uint64(0x01) != 0 || x.dirty&(uint64(0x01)<<3) != 0 {
		x.xxx_hidden_Bag.clearDirty()
	}
	x.dirty = 0
}

type dirtyParentFunc_PlayerBasicInfo func()

func (f dirtyParentFunc_PlayerBasicInfo) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBasicInfo struct {
	xxx_hidden_Name string
	xxx_hidden_IsNew bool
	xxx_hidden_CreateTime time.Time

	dirty       uint64
	dirtyParent dirtyParentFunc_PlayerBasicInfo
}

func NewPlayerBasicInfo() *PlayerBasicInfo {
	x := new(PlayerBasicInfo)
	x.dirty = 1
	return x
}

func (x *PlayerBasicInfo) GetName() string {
	return x.xxx_hidden_Name
}

func (x *PlayerBasicInfo) SetName(v string) {
	if v == x.xxx_hidden_Name {
		return
	}
	x.xxx_hidden_Name = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *PlayerBasicInfo) GetIsNew() bool {
	return x.xxx_hidden_IsNew
}

func (x *PlayerBasicInfo) SetIsNew(v bool) {
	if v == x.xxx_hidden_IsNew {
		return
	}
	x.xxx_hidden_IsNew = v
	x.markDirty(uint64(0x01) << 3)
}

func (x *PlayerBasicInfo) GetCreateTime() time.Time {
	return x.xxx_hidden_CreateTime
}

func (x *PlayerBasicInfo) SetCreateTime(v time.Time) {
	if v.Equal(x.xxx_hidden_CreateTime) {
		return
	}
	x.xxx_hidden_CreateTime = v
	x.markDirty(uint64(0x01) << 5)
}

func (x *PlayerBasicInfo) DumpChange() *kdspb.PlayerBasicInfo {
	if x.dirty&uint64(0x01) != 0 {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerBasicInfo)
	if x.dirty&(uint64(0x01)<<1) != 0 {
		m.SetName(x.xxx_hidden_Name)
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		m.SetIsNew(x.xxx_hidden_IsNew)
	}
	if x.dirty&(uint64(0x01)<<5) != 0 {
		m.SetCreateTime(timestamppb.New(x.xxx_hidden_CreateTime))
	}
	return m
}

func (x *PlayerBasicInfo) DumpFull() *kdspb.PlayerBasicInfo {
	m := new(kdspb.PlayerBasicInfo)
	m.SetName(x.xxx_hidden_Name)
	m.SetIsNew(x.xxx_hidden_IsNew)
	m.SetCreateTime(timestamppb.New(x.xxx_hidden_CreateTime))
	return m
}

func (x *PlayerBasicInfo) Load(m *kdspb.PlayerBasicInfo) {
	x.xxx_hidden_Name = m.GetName()
	x.xxx_hidden_IsNew = m.GetIsNew()
	x.xxx_hidden_CreateTime = m.GetCreateTime().AsTime()
}

func (x *PlayerBasicInfo) Marshal(b []byte) ([]byte, error) {
	var err error
	if b, err = wire.MarshalString(b, 1, x.xxx_hidden_Name); err != nil {
		return b, err
	}
	if b, err = wire.MarshalBool(b, 3, x.xxx_hidden_IsNew); err != nil {
		return b, err
	}
	if b, err = wire.MarshalTimestamp(b, 5, x.xxx_hidden_CreateTime); err != nil {
		return b, err
	}
	return b, err
}

func (x *PlayerBasicInfo) MarshalDirty(b []byte) ([]byte, error) {
	if x.dirty&uint64(0x01) != 0 {
		return x.Marshal(b)
	}
	var err error
	if x.dirty&(uint64(0x01)<<1) != 0 {
		if b, err = wire.MarshalString(b, 1, x.xxx_hidden_Name); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		if b, err = wire.MarshalBool(b, 3, x.xxx_hidden_IsNew); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<5) != 0 {
		if b, err = wire.MarshalTimestamp(b, 5, x.xxx_hidden_CreateTime); err != nil {
			return b, err
		}
	}
	return b, err
}

func (x *PlayerBasicInfo) Unmarshal(b []byte) error {
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case 1:
			x.xxx_hidden_Name, valLen, err = wire.UnmarshalString(b[tagLen:], wtyp)
		case 3:
			x.xxx_hidden_IsNew, valLen, err = wire.UnmarshalBool(b[tagLen:], wtyp)
		case 5:
			x.xxx_hidden_CreateTime, valLen, err = wire.UnmarshalTimestamp(b[tagLen:], wtyp)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	return nil
}

func (x *PlayerBasicInfo) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerBasicInfo) markDirty(n uint64) {
	if x.dirty&n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerBasicInfo) checkDirty(n uint64) bool {
	return x.dirty&n != 0
}

func (x *PlayerBasicInfo) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

type dirtyParentFunc_PlayerHero func()

func (f dirtyParentFunc_PlayerHero) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerHero struct {
	xxx_hidden_Heroes Int64Hero_map

	dirty       uint64
	dirtyParent dirtyParentFunc_PlayerHero
}

func NewPlayerHero() *PlayerHero {
	x := new(PlayerHero)
	x.dirty = 1
	x.initHeroes()
	return x
}

func (x *PlayerHero) GetHeroes() *Int64Hero_map {
	return &x.xxx_hidden_Heroes
}

func (x *PlayerHero) initHeroes() {
	x.xxx_hidden_Heroes.data = make(map[int64]*Hero)
	x.xxx_hidden_Heroes.updates = make(map[int64]*Hero)
	x.xxx_hidden_Heroes.deletes = make(map[int64]struct{})
	x.xxx_hidden_Heroes.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *PlayerHero) DumpChange() *kdspb.PlayerHero {
	if x.dirty&uint64(0x01) != 0 {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerHero)
	if x.dirty&(uint64(0x01)<<1) != 0 {
		m.SetHeroes(x.xxx_hidden_Heroes.DumpChange())
	}
	return m
}

func (x *PlayerHero) DumpFull() *kdspb.PlayerHero {
	m := new(kdspb.PlayerHero)
	m.SetHeroes(x.xxx_hidden_Heroes.DumpFull())
	return m
}

func (x *PlayerHero) Load(m *kdspb.PlayerHero) {
	x.xxx_hidden_Heroes.Load(m.GetHeroes())
}

func (x *PlayerHero) Marshal(b []byte) ([]byte, error) {
	var err error
	if b, err = wire.MarshalMessage(b, 1, &x.xxx_hidden_Heroes); err != nil {
		return b, err
	}
	return b, err
}

func (x *PlayerHero) MarshalDirty(b []byte) ([]byte, error) {
	if x.dirty&uint64(0x01) != 0 {
		return x.Marshal(b)
	}
	var err error
	if x.dirty&(uint64(0x01)<<1) != 0 {
		if b, err = wire.MarshalMessageDirty(b, 1, &x.xxx_hidden_Heroes); err != nil {
			return b, err
		}
	}
	return b, err
}

func (x *PlayerHero) Unmarshal(b []byte) error {
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case 1:
			valLen, err = wire.UnmarshalMessage(b[tagLen:], wtyp, &x.xxx_hidden_Heroes)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	return nil
}

func (x *PlayerHero) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerHero) markDirty(n uint64) {
	if x.dirty&n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerHero) checkDirty(n uint64) bool {
	return x.dirty&n != 0
}

func (x *PlayerHero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty&uint64(0x01) != 0 || x.dirty&(uint64(0x01)<<1) != 0 {
		x.xxx_hidden_Heroes.clearDirty()
	}
	x.dirty = 0
}

type dirtyParentFunc_PlayerBag func()

func (f dirtyParentFunc_PlayerBag) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBag struct {
	xxx_hidden_Resources Int32Int32_map

	dirty       uint64
	dirtyParent dirtyParentFunc_PlayerBag
}

func NewPlayerBag() *PlayerBag {
	x := new(PlayerBag)
	x.dirty = 1
	x.initResources()
	return x
}

func (x *PlayerBag) GetResources() *Int32Int32_map {
	return &x.xxx_hidden_Resources
}

func (x *PlayerBag) initResources() {
	x.xxx_hidden_Resources.data = make(map[int32]int32)
	x.xxx_hidden_Resources.updates = make(map[int32]int32)
	x.xxx_hidden_Resources.deletes = make(map[int32]struct{})
	x.xxx_hidden_Resources.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *PlayerBag) DumpChange() *kdspb.PlayerBag {
	if x.dirty&uint64(0x01) != 0 {
		return x.DumpFull()
	}
	m := new(kdspb.PlayerBag)
	if x.dirty&(uint64(0x01)<<1) != 0 {
		m.SetResources(x.xxx_hidden_Resources.DumpChange())
	}
	return m
}

func (x *PlayerBag) DumpFull() *kdspb.PlayerBag {
	m := new(kdspb.PlayerBag)
	m.SetResources(x.xxx_hidden_Resources.DumpFull())
	return m
}

func (x *PlayerBag) Load(m *kdspb.PlayerBag) {
	x.xxx_hidden_Resources.Load(m.GetResources())
}

func (x *PlayerBag) Marshal(b []byte) ([]byte, error) {
	var err error
	if b, err = wire.MarshalMessage(b, 1, &x.xxx_hidden_Resources); err != nil {
		return b, err
	}
	return b, err
}

func (x *PlayerBag) MarshalDirty(b []byte) ([]byte, error) {
	if x.dirty&uint64(0x01) != 0 {
		return x.Marshal(b)
	}
	var err error
	if x.dirty&(uint64(0x01)<<1) != 0 {
		if b, err = wire.MarshalMessageDirty(b, 1, &x.xxx_hidden_Resources); err != nil {
			return b, err
		}
	}
	return b, err
}

func (x *PlayerBag) Unmarshal(b []byte) error {
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case 1:
			valLen, err = wire.UnmarshalMessage(b[tagLen:], wtyp, &x.xxx_hidden_Resources)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	return nil
}

func (x *PlayerBag) markAll() {
	x.dirty = uint64(0x01)
}

func (x *PlayerBag) markDirty(n uint64) {
	if x.dirty&n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *PlayerBag) checkDirty(n uint64) bool {
	return x.dirty&n != 0
}

func (x *PlayerBag) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty&uint64(0x01) != 0 || x.dirty&(uint64(0x01)<<1) != 0 {
		x.xxx_hidden_Resources.clearDirty()
	}
	x.dirty = 0
}

type dirtyParentFunc_Hero func()

func (f dirtyParentFunc_Hero) invoke() {
	if f == nil {
		return
	}
	f()
}

type Hero struct {
	xxx_hidden_HeroId int32
	xxx_hidden_HeroLevel int32
	xxx_hidden_Type HeroType
	xxx_hidden_NeedTime time.Duration

	dirty       uint64
	dirtyParent dirtyParentFunc_Hero
}

func NewHero() *Hero {
	x := new(Hero)
	x.dirty = 1
	return x
}

func (x *Hero) GetHeroId() int32 {
	return x.xxx_hidden_HeroId
}

func (x *Hero) SetHeroId(v int32) {
	if v == x.xxx_hidden_HeroId {
		return
	}
	x.xxx_hidden_HeroId = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *Hero) GetHeroLevel() int32 {
	return x.xxx_hidden_HeroLevel
}

func (x *Hero) SetHeroLevel(v int32) {
	if v == x.xxx_hidden_HeroLevel {
		return
	}
	x.xxx_hidden_HeroLevel = v
	x.markDirty(uint64(0x01) << 2)
}

func (x *Hero) GetType() HeroType {
	return x.xxx_hidden_Type
}

func (x *Hero) SetType(v HeroType) {
	if v == x.xxx_hidden_Type {
		return
	}
	x.xxx_hidden_Type = v
	x.markDirty(uint64(0x01) << 3)
}

func (x *Hero) GetNeedTime() time.Duration {
	return x.xxx_hidden_NeedTime
}

func (x *Hero) SetNeedTime(v time.Duration) {
	if v == x.xxx_hidden_NeedTime {
		return
	}
	x.xxx_hidden_NeedTime = v
	x.markDirty(uint64(0x01) << 4)
}

func (x *Hero) DumpChange() *kdspb.Hero {
	if x.dirty&uint64(0x01) != 0 {
		return x.DumpFull()
	}
	m := new(kdspb.Hero)
	if x.dirty&(uint64(0x01)<<1) != 0 {
		m.SetHeroId(x.xxx_hidden_HeroId)
	}
	if x.dirty&(uint64(0x01)<<2) != 0 {
		m.SetHeroLevel(x.xxx_hidden_HeroLevel)
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		m.SetType(x.xxx_hidden_Type)
	}
	if x.dirty&(uint64(0x01)<<4) != 0 {
		m.SetNeedTime(durationpb.New(x.xxx_hidden_NeedTime))
	}
	return m
}

func (x *Hero) DumpFull() *kdspb.Hero {
	m := new(kdspb.Hero)
	m.SetHeroId(x.xxx_hidden_HeroId)
	m.SetHeroLevel(x.xxx_hidden_HeroLevel)
	m.SetType(x.xxx_hidden_Type)
	m.SetNeedTime(durationpb.New(x.xxx_hidden_NeedTime))
	return m
}

func (x *Hero) Load(m *kdspb.Hero) {
	x.xxx_hidden_HeroId = m.GetHeroId()
	x.xxx_hidden_HeroLevel = m.GetHeroLevel()
	x.xxx_hidden_Type = m.GetType()
	x.xxx_hidden_NeedTime = m.GetNeedTime().AsDuration()
}

func (x *Hero) Marshal(b []byte) ([]byte, error) {
	var err error
	if b, err = wire.MarshalInt32(b, 1, x.xxx_hidden_HeroId); err != nil {
		return b, err
	}
	if b, err = wire.MarshalInt32(b, 2, x.xxx_hidden_HeroLevel); err != nil {
		return b, err
	}
	// FIXME: enum value
	if b, err = wire.MarshalInt32(b, 3, int32(x.xxx_hidden_Type)); err != nil {
		return b, err
	}
	if b, err = wire.MarshalDuration(b, 4, x.xxx_hidden_NeedTime); err != nil {
		return b, err
	}
	return b, err
}

func (x *Hero) MarshalDirty(b []byte) ([]byte, error) {
	if x.dirty&uint64(0x01) != 0 {
		return x.Marshal(b)
	}
	var err error
	if x.dirty&(uint64(0x01)<<1) != 0 {
		if b, err = wire.MarshalInt32(b, 1, x.xxx_hidden_HeroId); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<2) != 0 {
		if b, err = wire.MarshalInt32(b, 2, x.xxx_hidden_HeroLevel); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<3) != 0 {
		// FIXME: enum value
		if b, err = wire.MarshalInt32(b, 3, int32(x.xxx_hidden_Type)); err != nil {
			return b, err
		}
	}
	if x.dirty&(uint64(0x01)<<4) != 0 {
		if b, err = wire.MarshalDuration(b, 4, x.xxx_hidden_NeedTime); err != nil {
			return b, err
		}
	}
	return b, err
}

func (x *Hero) Unmarshal(b []byte) error {
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case 1:
			x.xxx_hidden_HeroId, valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
		case 2:
			x.xxx_hidden_HeroLevel, valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
		case 3:
			// FIXME: enum value
			*(*int32)(&x.xxx_hidden_Type), valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
		case 4:
			x.xxx_hidden_NeedTime, valLen, err = wire.UnmarshalDuration(b[tagLen:], wtyp)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	return nil
}

func (x *Hero) markAll() {
	x.dirty = uint64(0x01)
}

func (x *Hero) markDirty(n uint64) {
	if x.dirty&n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *Hero) checkDirty(n uint64) bool {
	return x.dirty&n != 0
}

func (x *Hero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

type dirtyParentFunc_Int64Hero_map func()

func (f dirtyParentFunc_Int64Hero_map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int64Hero_map struct {
	data map[int64]*Hero

	clear       bool
	updates     map[int64]*Hero
	deletes     map[int64]struct{}
	dirty       bool
	dirtyParent dirtyParentFunc_Int64Hero_map
}

func (x *Int64Hero_map) Len() int {
	return len(x.data)
}

func (x *Int64Hero_map) Clear() {
	if len(x.data) == 0 && len(x.deletes) == 0 {
		return
	}
	for _, v := range x.data {
		if v != nil {
			v.dirtyParent = nil
		}
	}
	clear(x.data)
	x.clear = true
	clear(x.updates)
	clear(x.deletes)
	x.markDirty()
}

func (x *Int64Hero_map) Get(k int64) (*Hero, bool) {
	v, ok := x.data[k]
	return v, ok
}

func (x *Int64Hero_map) Set(k int64, v *Hero) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed from its original place first")
	}
	if e, ok := x.data[k]; ok {
		if e == v {
			return
		}
		if e != nil {
			e.dirtyParent = nil
		}
	}
	if v != nil {
		v.dirtyParent = func() {
			if _, ok := x.updates[k]; ok {
				return
			}
			x.updates[k] = v
			x.markDirty()
		}
		v.dirty |= uint64(0x01)
	}
	x.data[k] = v
	x.updates[k] = v
	delete(x.deletes, k)
	x.markDirty()
}

func (x *Int64Hero_map) Delete(k int64) {
	if v, ok := x.data[k]; !ok {
		return
	} else if v != nil {
		v.dirtyParent = nil
	}
	delete(x.data, k)
	delete(x.updates, k)
	x.deletes[k] = struct{}{}
	x.markDirty()
}

func (x *Int64Hero_map) All() iter.Seq2[int64, *Hero] {
	return maps.All(x.data)
}

func (x *Int64Hero_map) Keys() iter.Seq[int64] {
	return maps.Keys(x.data)
}

func (x *Int64Hero_map) Values() iter.Seq[*Hero] {
	return maps.Values(x.data)
}

func (x *Int64Hero_map) DumpChange() map[int64]*kdspb.Hero {
	if x.clear {
		return x.DumpFull()
	}
	m := make(map[int64]*kdspb.Hero)
	for k, v := range x.updates {
		m[k] = v.DumpFull()
	}
	for k, _ := range x.deletes {
		_ = k // deleteKeys
	}
	return m
}

func (x *Int64Hero_map) DumpFull() map[int64]*kdspb.Hero {
	m := make(map[int64]*kdspb.Hero)
	for k, v := range x.data {
		m[k] = v.DumpFull()
	}
	return m
}

func (x *Int64Hero_map) Load(m map[int64]*kdspb.Hero) {
	for k, v := range m {
		c := NewHero()
		c.Load(v)
		x.data[k] = c
	}
}

func (x *Int64Hero_map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int64Hero_map) clearDirty() {
	if !x.dirty {
		return
	}
	for _, v := range x.updates {
		if v != nil {
			v.clearDirty()
		}
	}
	x.clear = false
	clear(x.updates)
	clear(x.deletes)
	x.dirty = false
}

func (x *Int64Hero_map) Marshal(b []byte) ([]byte, error) {
	var pos int
	var err error
	if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
		return b, err
	}
	for k, v := range x.data {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt64(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalMessage(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int64Hero_map) MarshalDirty(b []byte) ([]byte, error) {
	var pos int
	var err error
	if x.clear {
		if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
			return b, err
		}
	}
	if len(x.deletes) > 0 {
		b = wire.AppendTag(b, wire.MapDeleteFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		for k, _ := range x.deletes {
			b = wire.AppendInt64(b, k)
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	for k, v := range x.updates {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt64(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalMessage(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int64Hero_map) Unmarshal(b []byte) error {
	var clear bool
	var deletes []byte
	var entries [][]byte
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case wire.MapClearFieldNumber:
			clear, valLen, err = wire.UnmarshalBool(b[tagLen:], wtyp)
		case wire.MapDeleteFieldNumber:
			deletes, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp)
		case wire.MapEntryFieldNumber:
			var entry []byte
			if entry, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp); err != nil {
				break
			}
			entries = append(entries, entry)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	if clear {
		x.Clear()
	}
	for b := deletes; len(b) > 0; {
		k, n, err := wire.ConsumeInt64(b)
		if err != nil {
			return err
		}
		b = b[n:]
		x.Delete(k)
	}
	for _, b := range entries {
		var k int64
		var v []byte
		for len(b) > 0 {
			num, wtyp, tagLen, err := wire.ConsumeTag(b)
			if err != nil {
				return err
			}
			var valLen int
			err = wire.ErrUnknown
			switch num {
			case wire.MapEntryKeyFieldNumber:
				k, valLen, err = wire.UnmarshalInt64(b[tagLen:], wtyp)
			case wire.MapEntryValueFieldNumber:
				v, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp)
			}
			if err == wire.ErrUnknown {
				if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
					return err
				}
			} else if err != nil {
				return err
			}
			b = b[tagLen+valLen:]
		}
		if c, ok := x.data[k]; !ok {
			c = NewHero()
			if err := c.Unmarshal(v); err != nil {
				return err
			}
			x.Set(k, c)
		} else if err := c.Unmarshal(v); err != nil {
			return err
		}
	}
	return nil
}

type HeroType = kdspb.HeroType

const (
	HeroType_HeroType1 HeroType = 0
	HeroType_HeroType2 HeroType = 2
	HeroType_HeroType3 HeroType = -5
)
