// Code generated by kds. DO NOT EDIT.
// source: example\common.kds

package kds;

import (
	"iter"
	"maps"
	"slices"

	"github.com/iakud/knoll/kds/wire"
	"google.golang.org/protobuf/types/known/emptypb"
)

type dirtyParentFunc_Int32_Empty_Map func()

func (f dirtyParentFunc_Int32_Empty_Map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32_Empty_Map struct {
	syncable map[int32]struct{}

	update map[int32]struct{}
	deleteKey map[int32]struct{}
	clear bool
	dirty bool
	dirtyParent dirtyParentFunc_Int32_Empty_Map
}

func (x *Int32_Empty_Map) Len() int {
	return len(x.syncable)
}

func (x *Int32_Empty_Map) Clear() {
	if len(x.syncable) == 0 && len(x.deleteKey) == 0 {
		return
	}
	clear(x.syncable)
	clear(x.update)
	clear(x.deleteKey)
	x.clear = true
	x.markDirty()
}

func (x *Int32_Empty_Map) Get(k int32) (struct{}, bool) {
	v, ok := x.syncable[k]
	return v, ok
}

func (x *Int32_Empty_Map) Set(k int32, v struct{}) {
	if e, ok := x.syncable[k]; ok {
		if e == v {
			return
		}
	}
	x.syncable[k] = v
	x.update[k] = v
	delete(x.deleteKey, k)
	x.markDirty()
}

func (x *Int32_Empty_Map) Delete(k int32) {
	if _, ok := x.syncable[k]; !ok {
		return
	}
	delete(x.syncable, k)
	x.deleteKey[k] = struct{}{}
	delete(x.update, k)
	x.markDirty()
}

func (x *Int32_Empty_Map) All() iter.Seq2[int32, struct{}] {
	return maps.All(x.syncable)
}

func (x *Int32_Empty_Map) Keys() iter.Seq[int32] {
	return maps.Keys(x.syncable)
}

func (x *Int32_Empty_Map) Values() iter.Seq[struct{}] {
	return maps.Values(x.syncable)
}

func (x *Int32_Empty_Map) DumpChange() map[int32]*emptypb.Empty {
	if x.clear {
		return x.DumpFull()
	}
	m := make(map[int32]*emptypb.Empty)
	for k := range x.update {
		m[k] = new(emptypb.Empty)
	}
	for k, _ := range x.deleteKey {
		_ = k // deleteKeys
	}
	return m
}

func (x *Int32_Empty_Map) DumpFull() map[int32]*emptypb.Empty {
	m := make(map[int32]*emptypb.Empty)
	for k := range x.syncable {
		m[k] = new(emptypb.Empty)
	}
	return m
}

func (x *Int32_Empty_Map) Load(m map[int32]*emptypb.Empty) {
	for k := range m {
		x.syncable[k] = struct{}{}
	}
}

func (x *Int32_Empty_Map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int32_Empty_Map) clearDirty() {
	if !x.dirty {
		return
	}
	clear(x.update)
	clear(x.deleteKey)
	x.clear = false
	x.dirty = false
}

func (x *Int32_Empty_Map) MarshalMap(b []byte) ([]byte, error) {
	if len(x.syncable) == 0 {
		return b, nil
	}
	var pos int
	var err error
	for k, v := range x.syncable {
		b = wire.AppendTag(b, 3, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, 1, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalEmpty(b, 2, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32_Empty_Map) unmarshalMap(b []byte) error {
	var key int32
	var value struct{}
	for len(b) > 0 {
		num, wtyp, n := wire.ConsumeTag(b)
		if n < 0 {
			return wire.ErrDecode
		}
		if num > wire.MaxValidNumber {
			return wire.ErrDecode
		}
		b = b[n:]

		err := wire.ErrUnknown
		switch num {
		case 1:
			n, err = wire.UnmarshalInt32(b, wtyp, &key)
		case 2:
			n, err = wire.UnmarshalEmpty(b, wtyp)
		}
		if err == wire.ErrUnknown {
			n = wire.ConsumeFieldValue(num, wtyp, b)
			if n < 0 {
				return wire.ErrDecode
			}
		} else if err != nil {
			return err
		}
		b = b[n:]
	}
	x.syncable[key] = value
	return nil
}

func (x *Int32_Empty_Map) UnmarshalMap(b []byte) error {
	for len(b) > 0 {
		num, wtyp, n := wire.ConsumeTag(b)
		if n < 0 {
			return wire.ErrDecode
		}
		if num > wire.MaxValidNumber {
			return wire.ErrDecode
		}
		b = b[n:]
		err := wire.ErrUnknown
		switch num {
		case 3:
			if wtyp != wire.BytesType {
				break
			}
			v, n := wire.ConsumeBytes(b)
			if n < 0 {
				return wire.ErrDecode
			}
			if err := x.unmarshalMap(v); err != nil {
				return err
			}
			err = nil
		}
		if err == wire.ErrUnknown {
			n = wire.ConsumeFieldValue(num, wtyp, b)
			if n < 0 {
				return wire.ErrDecode
			}
		} else if err != nil {
			return err
		}
		b = b[n:]
	}
	return nil
}

type dirtyParentFunc_Int32_Int32_Map func()

func (f dirtyParentFunc_Int32_Int32_Map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32_Int32_Map struct {
	syncable map[int32]int32

	update map[int32]int32
	deleteKey map[int32]struct{}
	clear bool
	dirty bool
	dirtyParent dirtyParentFunc_Int32_Int32_Map
}

func (x *Int32_Int32_Map) Len() int {
	return len(x.syncable)
}

func (x *Int32_Int32_Map) Clear() {
	if len(x.syncable) == 0 && len(x.deleteKey) == 0 {
		return
	}
	clear(x.syncable)
	clear(x.update)
	clear(x.deleteKey)
	x.clear = true
	x.markDirty()
}

func (x *Int32_Int32_Map) Get(k int32) (int32, bool) {
	v, ok := x.syncable[k]
	return v, ok
}

func (x *Int32_Int32_Map) Set(k int32, v int32) {
	if e, ok := x.syncable[k]; ok {
		if e == v {
			return
		}
	}
	x.syncable[k] = v
	x.update[k] = v
	delete(x.deleteKey, k)
	x.markDirty()
}

func (x *Int32_Int32_Map) Delete(k int32) {
	if _, ok := x.syncable[k]; !ok {
		return
	}
	delete(x.syncable, k)
	x.deleteKey[k] = struct{}{}
	delete(x.update, k)
	x.markDirty()
}

func (x *Int32_Int32_Map) All() iter.Seq2[int32, int32] {
	return maps.All(x.syncable)
}

func (x *Int32_Int32_Map) Keys() iter.Seq[int32] {
	return maps.Keys(x.syncable)
}

func (x *Int32_Int32_Map) Values() iter.Seq[int32] {
	return maps.Values(x.syncable)
}

func (x *Int32_Int32_Map) DumpChange() map[int32]int32 {
	if x.clear {
		return x.DumpFull()
	}
	m := make(map[int32]int32)
	for k, v := range x.update {
		m[k] = v
	}
	for k, _ := range x.deleteKey {
		_ = k // deleteKeys
	}
	return m
}

func (x *Int32_Int32_Map) DumpFull() map[int32]int32 {
	m := make(map[int32]int32)
	for k, v := range x.syncable {
		m[k] = v
	}
	return m
}

func (x *Int32_Int32_Map) Load(m map[int32]int32) {
	for k, v := range m {
		x.syncable[k] = v
	}
}

func (x *Int32_Int32_Map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int32_Int32_Map) clearDirty() {
	if !x.dirty {
		return
	}
	clear(x.update)
	clear(x.deleteKey)
	x.clear = false
	x.dirty = false
}

func (x *Int32_Int32_Map) MarshalMap(b []byte) ([]byte, error) {
	if len(x.syncable) == 0 {
		return b, nil
	}
	var pos int
	var err error
	for k, v := range x.syncable {
		b = wire.AppendTag(b, 3, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, 1, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalInt32(b, 2, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32_Int32_Map) unmarshalMap(b []byte) error {
	var key int32
	var value int32
	for len(b) > 0 {
		num, wtyp, n := wire.ConsumeTag(b)
		if n < 0 {
			return wire.ErrDecode
		}
		if num > wire.MaxValidNumber {
			return wire.ErrDecode
		}
		b = b[n:]

		err := wire.ErrUnknown
		switch num {
		case 1:
			n, err = wire.UnmarshalInt32(b, wtyp, &key)
		case 2:
			n, err = wire.UnmarshalInt32(b, wtyp, &value)
		}
		if err == wire.ErrUnknown {
			n = wire.ConsumeFieldValue(num, wtyp, b)
			if n < 0 {
				return wire.ErrDecode
			}
		} else if err != nil {
			return err
		}
		b = b[n:]
	}
	x.syncable[key] = value
	return nil
}

func (x *Int32_Int32_Map) UnmarshalMap(b []byte) error {
	for len(b) > 0 {
		num, wtyp, n := wire.ConsumeTag(b)
		if n < 0 {
			return wire.ErrDecode
		}
		if num > wire.MaxValidNumber {
			return wire.ErrDecode
		}
		b = b[n:]
		err := wire.ErrUnknown
		switch num {
		case 3:
			if wtyp != wire.BytesType {
				break
			}
			v, n := wire.ConsumeBytes(b)
			if n < 0 {
				return wire.ErrDecode
			}
			if err := x.unmarshalMap(v); err != nil {
				return err
			}
			err = nil
		}
		if err == wire.ErrUnknown {
			n = wire.ConsumeFieldValue(num, wtyp, b)
			if n < 0 {
				return wire.ErrDecode
			}
		} else if err != nil {
			return err
		}
		b = b[n:]
	}
	return nil
}

type dirtyParentFunc_Int64_List func()

func (f dirtyParentFunc_Int64_List) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int64_List struct {
	syncable []int64

	dirty bool
	dirtyParent dirtyParentFunc_Int64_List
}

func (x *Int64_List) Len() int {
	return len(x.syncable)
}

func (x *Int64_List) Clear() {
	if len(x.syncable) == 0 {
		return
	}
	clear(x.syncable)
	x.syncable = x.syncable[:0]
	x.markDirty()
}

func (x *Int64_List) Get(i int) int64 {
	return x.syncable[i]
}

func (x *Int64_List) Set(i int, v int64) {
	if v == x.syncable[i] {
		return
	}
	x.syncable[i] = v
	x.markDirty()
}

func (x *Int64_List) Append(v ...int64) {
	if len(v) == 0 {
		return
	}
	x.syncable = append(x.syncable, v...)
	x.markDirty()
}

func (x *Int64_List) Index(v int64) int {
	for i := range x.syncable {
		if v == x.syncable[i] {
			return i
		}
	}
	return -1
}

func (x *Int64_List) IndexFunc(f func(int64) bool) int {
	for i := range x.syncable {
		if f(x.syncable[i]) {
			return i
		}
	}
	return -1
}

func (x *Int64_List) Contains(v int64) bool {
	return x.Index(v) >= 0
}

func (x *Int64_List) ContainsFunc(f func(int64) bool) bool {
	return x.IndexFunc(f) >= 0
}

func (x *Int64_List) Insert(i int, v ...int64) {
	if len(v) == 0 {
		return
	}
	x.syncable = slices.Insert(x.syncable, i, v...)
	x.markDirty()
}

func (x *Int64_List) Delete(i, j int) {
	if i == j {
		return
	}
	x.syncable = slices.Delete(x.syncable, i, j)
	x.markDirty()
}

func (x *Int64_List) DeleteFunc(del func(int64) bool) {
	i := x.IndexFunc(del)
	if i == -1 {
		return
	}
	for j := i + 1; j < len(x.syncable); j++ {
		v := x.syncable[j]
		if del(v) {
			continue
		}
		x.syncable[i] = v
		i++
	}
	clear(x.syncable[i:])
	x.syncable = x.syncable[:i]
	x.markDirty()
}

func (x *Int64_List) Replace(i, j int, v ...int64) {
	if i == j && len(v) == 0 {
		return
	}
	x.syncable = slices.Replace(x.syncable, i, j, v...)
	x.markDirty()
}

func (x *Int64_List) Reverse() {
	if len(x.syncable) < 2 {
		return
	}
	slices.Reverse(x.syncable)
	x.markDirty()
}

func (x *Int64_List) All() iter.Seq2[int, int64] {
	return slices.All(x.syncable)
}

func (x *Int64_List) Backward() iter.Seq2[int, int64] {
	return slices.Backward(x.syncable)
}

func (x *Int64_List) Values() iter.Seq[int64] {
	return slices.Values(x.syncable)
}

func (x *Int64_List) DumpChange() []int64 {
	return x.DumpFull()
}

func (x *Int64_List) DumpFull() []int64 {
	var m []int64
	for _, v := range x.syncable {
		m = append(m, v)
	}
	return m
}

func (x *Int64_List) Load(m []int64) {
	for _, v := range m {
		x.syncable = append(x.syncable, v)
	}
}

func (x *Int64_List) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int64_List) clearDirty() {
	x.dirty = false
}

func (x *Int64_List) MarshalList(b []byte) ([]byte, error) {
	if len(x.syncable) == 0 {
		return b, nil
	}
	var err error
	for _, v := range x.syncable {
		b = wire.AppendInt64(b, v)
	}
	return b, err
}

func (x *Int64_List) UnmarshalList(b []byte) error {
	for len(b) > 0 {
		var value int64
		n, err := wire.UnmarshalInt64(b, wire.VarintType, &value)
		if err != nil {
			return err
		}
		b = b[n:]
		x.syncable = append(x.syncable, value)
	}
	return nil
}