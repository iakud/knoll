// Code generated by kds. DO NOT EDIT.
// source: example\common.kds

package kds

import (
	"iter"
	"maps"
	"slices"

	"github.com/iakud/knoll/kds/wire"
	"google.golang.org/protobuf/types/known/emptypb"
)

type dirtyParentFunc_Int32Empty_map func()

func (f dirtyParentFunc_Int32Empty_map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32Empty_map struct {
	data map[int32]struct{}

	clear       bool
	updates     map[int32]struct{}
	deletes     map[int32]struct{}
	dirty       bool
	dirtyParent dirtyParentFunc_Int32Empty_map
}

func (x *Int32Empty_map) Len() int {
	return len(x.data)
}

func (x *Int32Empty_map) Clear() {
	if len(x.data) == 0 && len(x.deletes) == 0 {
		return
	}
	clear(x.data)
	x.clear = true
	clear(x.updates)
	clear(x.deletes)
	x.markDirty()
}

func (x *Int32Empty_map) Get(k int32) (struct{}, bool) {
	v, ok := x.data[k]
	return v, ok
}

func (x *Int32Empty_map) Set(k int32, v struct{}) {
	if e, ok := x.data[k]; ok {
		if e == v {
			return
		}
	}
	x.data[k] = v
	x.updates[k] = v
	delete(x.deletes, k)
	x.markDirty()
}

func (x *Int32Empty_map) Delete(k int32) {
	if _, ok := x.data[k]; !ok {
		return
	}
	delete(x.data, k)
	delete(x.updates, k)
	x.deletes[k] = struct{}{}
	x.markDirty()
}

func (x *Int32Empty_map) All() iter.Seq2[int32, struct{}] {
	return maps.All(x.data)
}

func (x *Int32Empty_map) Keys() iter.Seq[int32] {
	return maps.Keys(x.data)
}

func (x *Int32Empty_map) Values() iter.Seq[struct{}] {
	return maps.Values(x.data)
}

func (x *Int32Empty_map) DumpChange() map[int32]*emptypb.Empty {
	if x.clear {
		return x.DumpFull()
	}
	m := make(map[int32]*emptypb.Empty)
	for k := range x.updates {
		m[k] = new(emptypb.Empty)
	}
	for k, _ := range x.deletes {
		_ = k // deleteKeys
	}
	return m
}

func (x *Int32Empty_map) DumpFull() map[int32]*emptypb.Empty {
	m := make(map[int32]*emptypb.Empty)
	for k := range x.data {
		m[k] = new(emptypb.Empty)
	}
	return m
}

func (x *Int32Empty_map) Load(m map[int32]*emptypb.Empty) {
	for k := range m {
		x.data[k] = struct{}{}
	}
}

func (x *Int32Empty_map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int32Empty_map) clearDirty() {
	if !x.dirty {
		return
	}
	x.clear = false
	clear(x.updates)
	clear(x.deletes)
	x.dirty = false
}

func (x *Int32Empty_map) Marshal(b []byte) ([]byte, error) {
	var pos int
	var err error
	if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
		return b, err
	}
	for k, v := range x.data {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalEmpty(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32Empty_map) MarshalDirty(b []byte) ([]byte, error) {
	var pos int
	var err error
	if x.clear {
		if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
			return b, err
		}
	}
	if len(x.deletes) > 0 {
		b = wire.AppendTag(b, wire.MapDeleteFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		for k, _ := range x.deletes {
			b = wire.AppendInt32(b, k)
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	for k, v := range x.updates {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalEmpty(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32Empty_map) Unmarshal(b []byte) error {
	var clear bool
	var deletes []byte
	var entries [][]byte
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case wire.MapClearFieldNumber:
			clear, valLen, err = wire.UnmarshalBool(b[tagLen:], wtyp)
		case wire.MapDeleteFieldNumber:
			deletes, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp)
		case wire.MapEntryFieldNumber:
			var entry []byte
			if entry, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp); err != nil {
				break
			}
			entries = append(entries, entry)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	if clear {
		x.Clear()
	}
	for b := deletes; len(b) > 0; {
		k, n, err := wire.ConsumeInt32(b)
		if err != nil {
			return err
		}
		b = b[n:]
		x.Delete(k)
	}
	for _, b := range entries {
		var k int32
		var v struct{}
		for len(b) > 0 {
			num, wtyp, tagLen, err := wire.ConsumeTag(b)
			if err != nil {
				return err
			}
			var valLen int
			err = wire.ErrUnknown
			switch num {
			case wire.MapEntryKeyFieldNumber:
				k, valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
			case wire.MapEntryValueFieldNumber:
				v, valLen, err = wire.UnmarshalEmpty(b[tagLen:], wtyp)
			}
			if err == wire.ErrUnknown {
				if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
					return err
				}
			} else if err != nil {
				return err
			}
			b = b[tagLen+valLen:]
		}
		x.Set(k, v)
	}
	return nil
}

type dirtyParentFunc_Int32Int32_map func()

func (f dirtyParentFunc_Int32Int32_map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32Int32_map struct {
	data map[int32]int32

	clear       bool
	updates     map[int32]int32
	deletes     map[int32]struct{}
	dirty       bool
	dirtyParent dirtyParentFunc_Int32Int32_map
}

func (x *Int32Int32_map) Len() int {
	return len(x.data)
}

func (x *Int32Int32_map) Clear() {
	if len(x.data) == 0 && len(x.deletes) == 0 {
		return
	}
	clear(x.data)
	x.clear = true
	clear(x.updates)
	clear(x.deletes)
	x.markDirty()
}

func (x *Int32Int32_map) Get(k int32) (int32, bool) {
	v, ok := x.data[k]
	return v, ok
}

func (x *Int32Int32_map) Set(k int32, v int32) {
	if e, ok := x.data[k]; ok {
		if e == v {
			return
		}
	}
	x.data[k] = v
	x.updates[k] = v
	delete(x.deletes, k)
	x.markDirty()
}

func (x *Int32Int32_map) Delete(k int32) {
	if _, ok := x.data[k]; !ok {
		return
	}
	delete(x.data, k)
	delete(x.updates, k)
	x.deletes[k] = struct{}{}
	x.markDirty()
}

func (x *Int32Int32_map) All() iter.Seq2[int32, int32] {
	return maps.All(x.data)
}

func (x *Int32Int32_map) Keys() iter.Seq[int32] {
	return maps.Keys(x.data)
}

func (x *Int32Int32_map) Values() iter.Seq[int32] {
	return maps.Values(x.data)
}

func (x *Int32Int32_map) DumpChange() map[int32]int32 {
	if x.clear {
		return x.DumpFull()
	}
	m := make(map[int32]int32)
	for k, v := range x.updates {
		m[k] = v
	}
	for k, _ := range x.deletes {
		_ = k // deleteKeys
	}
	return m
}

func (x *Int32Int32_map) DumpFull() map[int32]int32 {
	m := make(map[int32]int32)
	for k, v := range x.data {
		m[k] = v
	}
	return m
}

func (x *Int32Int32_map) Load(m map[int32]int32) {
	for k, v := range m {
		x.data[k] = v
	}
}

func (x *Int32Int32_map) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int32Int32_map) clearDirty() {
	if !x.dirty {
		return
	}
	x.clear = false
	clear(x.updates)
	clear(x.deletes)
	x.dirty = false
}

func (x *Int32Int32_map) Marshal(b []byte) ([]byte, error) {
	var pos int
	var err error
	if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
		return b, err
	}
	for k, v := range x.data {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalInt32(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32Int32_map) MarshalDirty(b []byte) ([]byte, error) {
	var pos int
	var err error
	if x.clear {
		if b, err = wire.MarshalBool(b, wire.MapClearFieldNumber, true); err != nil {
			return b, err
		}
	}
	if len(x.deletes) > 0 {
		b = wire.AppendTag(b, wire.MapDeleteFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		for k, _ := range x.deletes {
			b = wire.AppendInt32(b, k)
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	for k, v := range x.updates {
		b = wire.AppendTag(b, wire.MapEntryFieldNumber, wire.BytesType)
		b, pos = wire.AppendSpeculativeLength(b)
		if b, err = wire.MarshalInt32(b, wire.MapEntryKeyFieldNumber, k); err != nil {
			return b, err
		}
		if b, err = wire.MarshalInt32(b, wire.MapEntryValueFieldNumber, v); err != nil {
			return b, err
		}
		b = wire.FinishSpeculativeLength(b, pos)
	}
	return b, err
}

func (x *Int32Int32_map) Unmarshal(b []byte) error {
	var clear bool
	var deletes []byte
	var entries [][]byte
	for len(b) > 0 {
		num, wtyp, tagLen, err := wire.ConsumeTag(b)
		if err != nil {
			return err
		}
		var valLen int
		err = wire.ErrUnknown
		switch num {
		case wire.MapClearFieldNumber:
			clear, valLen, err = wire.UnmarshalBool(b[tagLen:], wtyp)
		case wire.MapDeleteFieldNumber:
			deletes, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp)
		case wire.MapEntryFieldNumber:
			var entry []byte
			if entry, valLen, err = wire.UnmarshalBytes(b[tagLen:], wtyp); err != nil {
				break
			}
			entries = append(entries, entry)
		}
		if err == wire.ErrUnknown {
			if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		b = b[tagLen+valLen:]
	}
	if clear {
		x.Clear()
	}
	for b := deletes; len(b) > 0; {
		k, n, err := wire.ConsumeInt32(b)
		if err != nil {
			return err
		}
		b = b[n:]
		x.Delete(k)
	}
	for _, b := range entries {
		var k int32
		var v int32
		for len(b) > 0 {
			num, wtyp, tagLen, err := wire.ConsumeTag(b)
			if err != nil {
				return err
			}
			var valLen int
			err = wire.ErrUnknown
			switch num {
			case wire.MapEntryKeyFieldNumber:
				k, valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
			case wire.MapEntryValueFieldNumber:
				v, valLen, err = wire.UnmarshalInt32(b[tagLen:], wtyp)
			}
			if err == wire.ErrUnknown {
				if valLen, err = wire.ConsumeFieldValue(num, wtyp, b[tagLen:]); err != nil {
					return err
				}
			} else if err != nil {
				return err
			}
			b = b[tagLen+valLen:]
		}
		x.Set(k, v)
	}
	return nil
}

type dirtyParentFunc_Int64_list func()

func (f dirtyParentFunc_Int64_list) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int64_list struct {
	data []int64

	dirty       bool
	dirtyParent dirtyParentFunc_Int64_list
}

func (x *Int64_list) Len() int {
	return len(x.data)
}

func (x *Int64_list) Clear() {
	if len(x.data) == 0 {
		return
	}
	clear(x.data)
	x.data = x.data[:0]
	x.markDirty()
}

func (x *Int64_list) Get(i int) int64 {
	return x.data[i]
}

func (x *Int64_list) Set(i int, v int64) {
	if v == x.data[i] {
		return
	}
	x.data[i] = v
	x.markDirty()
}

func (x *Int64_list) Append(v ...int64) {
	if len(v) == 0 {
		return
	}
	x.data = append(x.data, v...)
	x.markDirty()
}

func (x *Int64_list) Index(v int64) int {
	for i := range x.data {
		if v == x.data[i] {
			return i
		}
	}
	return -1
}

func (x *Int64_list) IndexFunc(f func(int64) bool) int {
	for i := range x.data {
		if f(x.data[i]) {
			return i
		}
	}
	return -1
}

func (x *Int64_list) Contains(v int64) bool {
	return x.Index(v) >= 0
}

func (x *Int64_list) ContainsFunc(f func(int64) bool) bool {
	return x.IndexFunc(f) >= 0
}

func (x *Int64_list) Insert(i int, v ...int64) {
	if len(v) == 0 {
		return
	}
	x.data = slices.Insert(x.data, i, v...)
	x.markDirty()
}

func (x *Int64_list) Delete(i, j int) {
	if i == j {
		return
	}
	x.data = slices.Delete(x.data, i, j)
	x.markDirty()
}

func (x *Int64_list) DeleteFunc(del func(int64) bool) {
	i := x.IndexFunc(del)
	if i == -1 {
		return
	}
	for j := i + 1; j < len(x.data); j++ {
		v := x.data[j]
		if del(v) {
			continue
		}
		x.data[i] = v
		i++
	}
	clear(x.data[i:])
	x.data = x.data[:i]
	x.markDirty()
}

func (x *Int64_list) Replace(i, j int, v ...int64) {
	if i == j && len(v) == 0 {
		return
	}
	x.data = slices.Replace(x.data, i, j, v...)
	x.markDirty()
}

func (x *Int64_list) Reverse() {
	if len(x.data) < 2 {
		return
	}
	slices.Reverse(x.data)
	x.markDirty()
}

func (x *Int64_list) All() iter.Seq2[int, int64] {
	return slices.All(x.data)
}

func (x *Int64_list) Backward() iter.Seq2[int, int64] {
	return slices.Backward(x.data)
}

func (x *Int64_list) Values() iter.Seq[int64] {
	return slices.Values(x.data)
}

func (x *Int64_list) DumpChange() []int64 {
	return x.DumpFull()
}

func (x *Int64_list) DumpFull() []int64 {
	var m []int64
	for _, v := range x.data {
		m = append(m, v)
	}
	return m
}

func (x *Int64_list) Load(m []int64) {
	for _, v := range m {
		x.data = append(x.data, v)
	}
}

func (x *Int64_list) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Int64_list) clearDirty() {
	x.dirty = false
}

func (x *Int64_list) Marshal(b []byte) ([]byte, error) {
	if len(x.data) == 0 {
		return b, nil
	}
	for _, v := range x.data {
		b = wire.AppendInt64(b, v)
	}
	return b, nil
}

func (x *Int64_list) MarshalDirty(b []byte) ([]byte, error) {
	return x.Marshal(b)
}

func (x *Int64_list) Unmarshal(b []byte) error {
	x.Clear()
	for len(b) > 0 {
		v, n, err := wire.ConsumeInt64(b)
		if err != nil {
			return err
		}
		b = b[n:]
		x.Append(v)
	}
	return nil
}
